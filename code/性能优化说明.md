# 手势识别系统 - 性能优化说明

## 📋 优化概览

本次优化针对实时手势识别系统的延迟、不同步和关键点残留问题进行了全面改进，目标是让**分数跟手**，实现流畅的实时反馈体验。

### 🎯 优化目标（量化指标）

| 指标 | 目标值 | 验证方法 |
|------|--------|----------|
| 手势变化 → Live Score 延迟 | < 300ms (最佳 < 150ms) | Debug 面板监控 `latency_ms` |
| 手移出画面 → 清空延迟 | ≤ 100ms | 目测骨架清空速度 |
| 渲染帧率 (Render FPS) | ≥ 18 fps | Debug 面板查看 `render_fps` |
| WebSocket 接收帧率 | 稳定 (无积压) | Debug 面板查看 `ws_recv_fps` |
| 推理耗时 | < 80ms | Debug 面板查看 `inference_ms` |
| 坐标绘制 | 无偏移、无镜像错误 | 目测手部与骨架对齐 |

---

## 🛠️ 主要改进

### 1. 前端优化

#### ✅ 最新帧策略 + requestAnimationFrame
- **问题**: 旧版本在 `onmessage` 中直接绘制，导致消息堆积和延迟累积
- **解决方案**: 
  - 使用 `latestMsgRef` 只保存最新消息，旧消息被覆盖
  - 统一在 `requestAnimationFrame` 循环中渲染，确保 60fps 同步

```typescript
// WebcamViewer.tsx 211-279 行
latestMsgRef.current = data; // onmessage 只保存数据
// rAF 循环中处理最新消息
```

#### ✅ No-hand 立即清空
- **问题**: 手移出画面后，骨架残留
- **解决方案**: 
  - 检测到 `hands_detected === false` 时，立即清空 canvas
  - 显示 "No hand detected" 提示

```typescript
// WebcamViewer.tsx 249-257 行
if (handsDetected && landmarks.length === 21) {
  drawLandmarks(ctx, landmarks, canvas.width, canvas.height, landmarksOk, videoMirrored);
} else {
  clearCanvas(ctx, canvas.width, canvas.height); // 无手立即清空
}
```

#### ✅ 同步画布尺寸与镜像
- **问题**: canvas 与 video 尺寸不一致，导致坐标偏移
- **解决方案**: 
  - 每帧检查并同步 `canvas.width/height = video.videoWidth/videoHeight`
  - 支持视频水平镜像 (`scaleX(-1)`)，绘制时自动镜像坐标

```typescript
// WebcamViewer.tsx 240-243 行
if (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight) {
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;
}

// drawHelpers.ts 85-86 行
const transformX = (x: number) => mirrored ? (1 - x) * width : x * width;
```

#### ✅ 摄像头性能优化
- **分辨率**: 640×480 (降低传输成本)
- **帧率**: 20-24 fps (避免过度推理)
- **JPEG 质量**: 0.6 (减少传输数据量)

```typescript
// WebcamViewer.tsx 373-381 行
const mediaStream = await navigator.mediaDevices.getUserMedia({
  video: {
    width: { ideal: 640 },
    height: { ideal: 480 },
    frameRate: { min: 20, ideal: 24, max: 24 }
  },
  audio: false,
});
```

#### ✅ 分数显示策略
- **Live Score**: 显示当前帧分数（即时响应）
- **进度条**: 使用 EMA 平滑分数（alpha=0.7，视觉稳定）
- **统计数据**: 与 Live Score 解耦，无手帧不计数

```typescript
// useGestureScore.ts 88-92 行
setSmoothScore((prevSmooth) => {
  const newSmooth = EMA_ALPHA * currentScore + (1 - EMA_ALPHA) * prevSmooth;
  return Math.round(newSmooth);
});
```

---

### 2. 后端优化

#### ✅ 只处理最新帧
- **问题**: 旧帧排队处理，导致延迟累积
- **解决方案**: 
  - WebSocket 服务只保存 `latestFrame`，旧帧被覆盖
  - Python 立即处理最新帧，无队列积压

```typescript
// websocket_service.ts 242-243 行
client.latestFrame = frameData; // 覆盖旧帧
```

#### ✅ 消息时间戳与性能打点
- **新增字段**:
  - `server_ts`: 服务器发送时间（毫秒）
  - `inference_ms`: 单帧推理耗时（毫秒）
- **用途**: 前端计算端到端延迟，定位性能瓶颈

```python
# realtime_recognition.py 268-269 行
'server_ts': int(time.time() * 1000),
'inference_ms': round(inference_time_ms, 2)
```

#### ✅ 放宽 landmarks_ok 判定（A/B 测试）
- **原阈值**: `avg_vis > 0.45 && bbox_area > 0.01`
- **用途**: 仅用于 UI 颜色提示，不参与分数降权
- **去除降权**: 保留原始 `confidence`，避免分数抖动

```python
# realtime_recognition.py 105 行
landmarks_ok = (avg_vis > 0.45 and bbox_area > 0.01)

# realtime_recognition.py 254 行
final_confidence = raw_confidence  # 不再降权
```

---

## 🎛️ Debug 面板使用指南

### 开启 / 关闭
- **快捷键**: 按 `D` 键切换显示
- **位置**: 视频画面右上角

### 显示指标

| 指标 | 说明 | 正常范围 | 颜色编码 |
|------|------|----------|----------|
| **Latency** | 网络延迟（客户端接收时间 - 服务器发送时间） | < 100ms 绿色 / < 300ms 黄色 / ≥ 300ms 红色 | 越低越好 |
| **Inference** | 后端推理耗时（单帧） | < 80ms 绿色 / ≥ 80ms 黄色 | 通常 30-60ms |
| **WS Recv FPS** | WebSocket 接收帧率 | ≥ 18 绿色 / < 18 红色 | 稳定不掉帧 |
| **Render FPS** | 前端渲染帧率 | ≥ 18 绿色 / < 18 红色 | 通常 20-30 |
| **Score Now** | 当前帧分数 | 0-100 | 实时跟手 |
| **Landmarks OK** | 关键点质量 | YES 绿色 / NO 红色 | 手势清晰时为 YES |

### 示例截图

```
┌─────────────────────────────┐
│  DEBUG PANEL                │
├─────────────────────────────┤
│  Latency:         85 ms     │  ✅ 绿色
│  Inference:       42.3 ms   │  ✅ 绿色
│  WS Recv FPS:     20        │  ✅ 绿色
│  Render FPS:      24        │  ✅ 绿色
│  Score Now:       87        │  
│  Landmarks OK:    YES       │  ✅ 绿色
│  按 D 键隐藏                │
└─────────────────────────────┘
```

---

## 🔧 配置参数位置

### 前端参数

| 参数 | 文件 | 行号 | 说明 |
|------|------|------|------|
| 摄像头分辨率 | `WebcamViewer.tsx` | 376-377 | `width: 640, height: 480` |
| 摄像头帧率 | `WebcamViewer.tsx` | 378 | `frameRate: { min: 20, ideal: 24, max: 24 }` |
| JPEG 质量 | `WebcamViewer.tsx` | 357 | `canvas.toDataURL('image/jpeg', 0.6)` |
| 发送帧率 | `WebcamViewer.tsx` | 414 | `setInterval(..., 50)` → 20fps |
| EMA 平滑系数 | `useGestureScore.ts` | 54 | `EMA_ALPHA = 0.7` |
| 视频镜像开关 | `WebcamViewer.tsx` | 113 | `videoMirrored = true` |

### 后端参数

| 参数 | 文件 | 行号 | 说明 |
|------|------|------|------|
| MediaPipe 置信度 | `realtime_recognition.py` | 24-25 | `min_detection_confidence=0.7` |
| Landmarks 质量阈值 | `realtime_recognition.py` | 105 | `avg_vis > 0.45 && bbox_area > 0.01` |
| EMA 缓存过期时间 | `realtime_recognition.py` | 54 | `MAX_CACHE_AGE = 300` 秒 |

---

## ✅ 验证步骤

### 1. 启动系统

```bash
# 后端
cd GestureWorkshop
npm run dev

# 前端（新终端）
cd GestureWorkshop/client
npm run dev
```

### 2. 浏览器测试
- 打开 `http://localhost:5173`
- **强制刷新**（禁用缓存）: `Ctrl + Shift + R` (Windows) / `Cmd + Shift + R` (Mac)

### 3. 开启 Debug 面板
- 按 `D` 键显示 Debug 面板

### 4. 三组验证测试

#### 测试 1: 正确手势稳定性
1. 开启摄像头 → 选择手势（如 "A"）→ 点击 "Start Recognition"
2. 做出正确手势，保持 1-2 秒
3. **观察指标**:
   - `Score Now` 应快速上升至 75+ 并稳定
   - `Latency` < 150ms（绿色）
   - `Render FPS` ≥ 18（绿色）
   - `Landmarks OK` = YES（绿色）
4. **截图保存** Debug 面板

#### 测试 2: 快速响应性
1. 快速做出握拳 → 松开 → 握拳（3 次循环）
2. **观察**:
   - `Score Now` 应在 0.5-1 秒内明显响应变化
   - 骨架实时跟随手部动作，无延迟残影
3. **截图保存** 快速变化时的 Debug 面板

#### 测试 3: No-hand 清空
1. 手移出摄像头画面
2. **观察**:
   - ≤ 100ms 内骨架完全清空
   - 显示 "No hand detected" 提示
   - `Score Now` = 0
   - `Landmarks OK` = NO（红色）
3. **截图保存** No-hand 状态

---

## 🐛 故障排查

### 问题 1: 延迟仍然很高 (Latency > 300ms)

**可能原因**:
- 网络连接慢
- 后端推理耗时过长（`Inference` > 80ms）

**解决方案**:
1. 降低模型输入分辨率到 320×240:
   ```typescript
   // WebcamViewer.tsx 347-348 行
   const TARGET_WIDTH = 320;
   const TARGET_HEIGHT = 240;
   ```

2. 或使用前端 MediaPipe Hands Web（将推理迁移到前端）:
   ```bash
   npm install @mediapipe/hands
   ```

### 问题 2: 渲染帧率低 (Render FPS < 18)

**可能原因**:
- CPU 性能不足
- 绘制逻辑过重

**解决方案**:
1. 简化绘制（仅绘制关键点，不绘制连线）
2. 降低发送帧率到 15fps:
   ```typescript
   // WebcamViewer.tsx 414 行
   setInterval(() => { processFrame(); }, 66); // 15fps
   ```

### 问题 3: 坐标偏移或镜像错误

**可能原因**:
- `videoMirrored` 设置错误

**解决方案**:
- 切换镜像开关:
  ```typescript
  // WebcamViewer.tsx 113 行
  const [videoMirrored, setVideoMirrored] = useState(false); // 改为 false
  ```

---

## 📊 性能基准参考

### 理想配置（Core i5 + 8GB RAM）

| 指标 | 预期值 |
|------|--------|
| Latency | 50-120 ms |
| Inference | 30-60 ms |
| WS Recv FPS | 18-22 |
| Render FPS | 20-30 |
| Score 响应时间 | < 200ms |

### 最低配置（Core i3 + 4GB RAM）

| 指标 | 预期值 |
|------|--------|
| Latency | 100-250 ms |
| Inference | 60-100 ms |
| WS Recv FPS | 15-18 |
| Render FPS | 15-20 |
| Score 响应时间 | < 500ms |

---

## 📝 日志示例

### 后端日志（正常运行）

```json
{"type": "perf", "avg_vis": 0.89, "bbox_area": 0.045, "landmarks_ok": true, "inference_ms": 42.3}
{"type": "perf", "avg_vis": 0.91, "bbox_area": 0.047, "landmarks_ok": true, "inference_ms": 38.7}
```

### 前端控制台日志

```
[WS FPS] 20 msg/s
[Render FPS] 24 frames/s
[Debug] Enabled
```

---

## 🎉 总结

本次优化通过以下关键技术实现了**分数跟手**的目标:

1. ✅ **最新帧策略** → 消除积压延迟
2. ✅ **rAF 统一渲染** → 同步 60fps 刷新
3. ✅ **No-hand 立即清空** → 消除残影
4. ✅ **镜像坐标支持** → 骨架对齐
5. ✅ **Debug 面板** → 实时监控性能
6. ✅ **分数解耦策略** → Live Score 灵敏 + 进度条平滑

---

## 📚 相关文档

- [快速开始指南](./QUICK_START.md)
- [评分系统说明](./修复完成_评分系统.md)
- [WebSocket 修复说明](./WebSocket修复说明.md)

---

**最后更新**: 2025-01-17  
**维护者**: GestureWorkshop Team



